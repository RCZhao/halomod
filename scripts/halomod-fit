#!/Users/Steven/anaconda/bin/python2.7
# encoding: utf-8
'''
halomod-fit -- fit a model to data

halomod-fit is a script for fitting arbitrary Halo Model quantities to given
data. For instance, it makes an MCMC fit to the projected correlation function
of galaxies a simple procedure. A config file is necessary to run the application. 
'''

import sys
import os
import traceback

from argparse import ArgumentParser
from argparse import RawDescriptionHelpFormatter
from ConfigParser import SafeConfigParser as cfg
cfg.optionxform = str
import numpy as np
from hod import fit as mc
import json
import time
from hod import HaloModel
import errno
from os.path import join

__all__ = []
__version__ = 0.1
__date__ = '2014-05-14'
__updated__ = '2014-05-14'

DEBUG = 0
TESTRUN = 0
PROFILE = 0

class CLIError(Exception):
    '''Generic exception to raise and log different fatal errors.'''
    def __init__(self, msg):
        super(CLIError).__init__(type(self))
        self.msg = "E: %s" % msg
    def __str__(self):
        return self.msg
    def __unicode__(self):
        return self.msg

def main(argv=None):
    '''Command line options.'''

    if argv is None:
        argv = sys.argv
    else:
        sys.argv.extend(argv)

    program_name = os.path.basename(sys.argv[0])
    program_version = "v%s" % __version__
    program_build_date = str(__updated__)
    program_version_message = '%%(prog)s %s (%s)' % (program_version, program_build_date)
    program_shortdesc = __import__('__main__').__doc__.split("\n")[1]
    program_license = '''%s

  Created by Steven Murray on %s.
  Copyright 2013 organization_name. All rights reserved.

  Licensed under the Apache License 2.0
  http://www.apache.org/licenses/LICENSE-2.0

  Distributed on an "AS IS" basis without warranties
  or conditions of any kind, either express or implied.

USAGE
''' % (program_shortdesc, str(__date__))

    try:
        # Setup argument parser
        parser = ArgumentParser(description=program_license, formatter_class=RawDescriptionHelpFormatter)
        parser.add_argument("-v", "--verbose", dest="verbose", action="count", help="set verbosity level [default: %(default)s]")
        parser.add_argument('-V', '--version', action='version', version=program_version_message)

        parser.add_argument("conf", help="config file")

        # Process arguments
        args = parser.parse_args()

        ### READ CONFIG FILE ###
        options = read_config(args.conf)

        if options["IO"]["outdir"]:
            try:
                os.makedirs(options["IO"]["outdir"])
            except OSError, e:
                if e.errno != errno.EEXIST:
                    raise

        r, data, sd, cov = get_data(options["Data"])

        priors, keys, guess = param_setup(options["CosmoParams"],
                                          options["OtherParams"])


        run(r, data, sd, cov, priors, keys, guess, options)

        #-----------------------------------------------------------------------
        return 0
    except KeyboardInterrupt:
        ### handle keyboard interrupt ###
        return 0
    except Exception, e:
        if DEBUG or TESTRUN:
            raise e
        traceback.print_exc()
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help\n")
        return 2

#===============================================================================
# PARAMETER SETUP
#===============================================================================
def get_data(opts):
    data = np.genfromtxt(opts["data_file"])

    r = data[:, 0]
    xi = data[:, 1]
    try:
        sd = data[:, 2]
    except IndexError:
        sd = None

    try:
        cov = np.genfromtxt(opts["cov_file"])
    except:
        cov = None

    if sd is None and cov is None:
        raise ValueError("Either a univariate standard deviation, or multivariate cov matrix must be provided.")

    return r, xi, sd, cov

def param_setup(cosmoparams, otherparams):

    priors = []
    guess = []

    av_data = ["WMAP3", "WMAP5", "WMAP9", "PLANCK"]
    print cosmoparams
    covdata = cosmoparams.pop("covar_data")

    print cosmoparams
    cosmo_priors = {k:json.loads(v) for k, v in cosmoparams.iteritems()}

    cov_vars = {k:v for k, v in cosmo_priors.iteritems() if v[0] == "cov"}
    var_vars = {k:v for k, v in cosmo_priors.iteritems() if v[0] == "var"}

    if covdata not in av_data or len(cov_vars) + len(var_vars) == 0:
        # # Simple Case
        otherparams.update(cosmoparams)
        for param, val in otherparams.iteritems():
            priors += set_prior(param, val)

    else:
        # # First do all params other than cosmo
        for param, val in otherparams.iteritems():
            priors += set_prior(param, val)

        # Now cosmo params
        from hod._covardata import data
        data = data[covar_data]
        all_params = ["omegab_h2", "omegac_h2", "n", "sigma_8", "H0"]
        cov_params = [k for k in cov_vars]
        var_params = [k for k in var_vars]

        if cov_params:
            indices = [cov_params.index(v) for v in cov_params]
            data['cov'] = data['cov'][indices, indices]
            data['mean'] = data['mean'][indices]
            priors += [mc.MultiNorm(cov_params, data['mean'], data['cov'])]
        if var_params:
            indices = [var_params.index(v) for v in var_params]
            data['cov'] = data['cov'][indices, indices]
            data['mean'] = data['mean'][indices]
            priors += [mc.Normal(use_params[i], data['mean'][i], np.sqrt(data['cov'][i, i])) for i in range(len(data['mean']))]

    # A list of all the names of parameters.
    keys = []
    for prior in priors:
        if isinstance(prior.name, basestring):
            keys += [prior.name]
        else:
            keys += prior.name

    # Get the guess
    guess = []
    otherparams.update(cosmoparams)
    for k in otherparams:
        val = json.loads(otherparams[k])
        guess.append(val[-1])

    print keys
    print guess
    for p in priors:
        print p.__dict__
    return priors, keys, guess

def set_prior(param, val):
    val = json.loads(val)
    if val[0] == 'flat':
        return [mc.Uniform(param, val[1], val[2])]
    elif val[1] == 'var':
        return [mc.Normal(param, val[1], val[2])]

#===============================================================================
# MAIN
#===============================================================================
def run(r, data, sd, cov, priors, keys, guess, options):

    kwargs = options["Model"]
    for k in kwargs:
        try:
            kwargs[k] = float(kwargs[k])
        except:
            pass

    nwalkers = int(options["MCMC"]["nwalkers"])
    nsamples = int(options["MCMC"]["nsamples"])
    burnin = int(options["MCMC"]["burnin"])
    nthreads = int(options["RunOptions"]["nthreads"])
    chunks = int(options["IO"]["chunks"])

    print type(nwalkers), type(nsamples), type(burnin)
    start = time.time()
    h = HaloModel(r=r, **kwargs)
    h.corr_gal

    prefix = join(options["IO"]["outdir"], options["IO"]["prefix"])
    chain, acceptance = mc.fit_hod(r, data, priors, h, guess,
                                   nwalkers, nsamples, burnin, nthreads,
                                   prefix + "chain", chunks,
                                   options["IO"]["verbose"],
                                   sd=sd, covar=cov)

    with open(prefix + "log", 'w') as f:
        f.write("Average time: %s\n" % ((time.time() - start) / (nwalkers * nsamples + nwalkers * burnin)))
        f.write("Mean values = %s\n" % np.mean(chain, axis=0))
        f.write("Covariance Matrix: %s\n" % np.cov(chain.T))
        f.write("Acceptance Fraction: %s\n" % acceptance)
        f.write("Nsamples:  %s\n" % nsamples)
        f.write("Nwalkers: %s\n" % nwalkers)

    # Write out final chain
    np.savetxt(prefix + "chain", chain, header="\t".join(keys))

#===============================================================================
# READ CONFIG
#===============================================================================
def read_config(fname):
    config = cfg()
    config.read(fname)
    res = {s:dict(config.items(s)) for s in config.sections()}
    if "outdir" not in res["IO"]:
        res["IO"]["outdir"] = ""
    if "prefix" not in res["IO"]:
        res["IO"]["prefix"] = ""
    if "covar_data" not in res["CosmoParams"]:
        res["CosmoParams"]["covar_data"] = ""
    return res


if __name__ == "__main__":
    if DEBUG:
        sys.argv.append("-v")
    if TESTRUN:
        import doctest
        doctest.testmod()
    if PROFILE:
        import cProfile
        import pstats
        profile_filename = 'run_profile.txt'
        cProfile.run('main()', profile_filename)
        statsfile = open("profile_stats.txt", "wb")
        p = pstats.Stats(profile_filename, stream=statsfile)
        stats = p.strip_dirs().sort_stats('cumulative')
        stats.print_stats()
        statsfile.close()
        sys.exit(0)
    sys.exit(main())

